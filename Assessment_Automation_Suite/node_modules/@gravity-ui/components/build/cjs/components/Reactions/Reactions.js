"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reactions = void 0;
const react_1 = __importDefault(require("react"));
const icons_1 = require("@gravity-ui/icons");
const uikit_1 = require("@gravity-ui/uikit");
const xor_1 = __importDefault(require("lodash/xor"));
const cn_1 = require("../utils/cn");
const Reaction_1 = require("./Reaction");
const context_1 = require("./context");
const i18n_1 = require("./i18n");
require("./Reactions.css");
const b = (0, cn_1.block)('reactions');
const buttonSizeToIconSize = {
    xs: '12px',
    s: '16px',
    m: '16px',
    l: '16px',
    xl: '20px',
};
function Reactions({ reactions, reactionsState, className, style, size = 'm', paletteProps, readOnly, qa, addButtonPlacement = 'end', renderTooltip, onToggle, }) {
    const [currentHoveredReaction, setCurrentHoveredReaction] = react_1.default.useState(undefined);
    const paletteOptionsMap = react_1.default.useMemo(() => reactions.reduce((acc, current) => {
        // eslint-disable-next-line no-param-reassign
        acc[current.value] = current;
        return acc;
    }, {}), [reactions]);
    const paletteValue = react_1.default.useMemo(() => reactionsState
        .filter((reaction) => reaction.selected)
        .map((reaction) => reaction.value), [reactionsState]);
    const onUpdatePalette = react_1.default.useCallback((updated) => {
        const diffValues = (0, xor_1.default)(paletteValue, updated);
        for (const diffValue of diffValues) {
            onToggle === null || onToggle === void 0 ? void 0 : onToggle(diffValue);
        }
    }, [onToggle, paletteValue]);
    const paletteContent = react_1.default.useMemo(() => (react_1.default.createElement(uikit_1.Palette, Object.assign({}, paletteProps, { options: reactions, value: paletteValue, size: size, onUpdate: onUpdatePalette }))), [paletteProps, reactions, paletteValue, size, onUpdatePalette]);
    const addReactionButton = readOnly ? null : (react_1.default.createElement(uikit_1.Popover, { content: paletteContent, tooltipContentClassName: b('add-reaction-popover'), openOnHover: false, hasArrow: false, focusTrap: true, autoFocus: true },
        react_1.default.createElement(uikit_1.Button, { className: b('reaction-button'), size: size, extraProps: { 'aria-label': (0, i18n_1.i18n)('add-reaction') }, view: "flat-secondary" },
            react_1.default.createElement(uikit_1.Button.Icon, null,
                react_1.default.createElement(uikit_1.Icon, { data: icons_1.FaceSmile, size: buttonSizeToIconSize[size] })))));
    return (react_1.default.createElement(context_1.ReactionsContextProvider, { value: {
            openedTooltip: currentHoveredReaction,
            setOpenedTooltip: setCurrentHoveredReaction,
        } },
        react_1.default.createElement(uikit_1.Flex, { className: b(null, className), style: style, gap: 1, wrap: true, qa: qa },
            addButtonPlacement === 'start' ? addReactionButton : null,
            reactionsState.map((reaction) => {
                var _a, _b;
                const content = (_b = (_a = paletteOptionsMap[reaction.value]) === null || _a === void 0 ? void 0 : _a.content) !== null && _b !== void 0 ? _b : '?';
                return (react_1.default.createElement(Reaction_1.Reaction, { key: reaction.value, content: content, reaction: reaction, size: size, tooltip: renderTooltip ? renderTooltip(reaction) : undefined, onClick: readOnly ? undefined : onToggle }));
            }),
            addButtonPlacement === 'end' ? addReactionButton : null)));
}
exports.Reactions = Reactions;

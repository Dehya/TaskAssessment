"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useReactionsPopup = void 0;
const react_1 = __importDefault(require("react"));
const context_1 = require("./context");
const DELAY = {
    focusTimeout: 600,
    openTimeout: 200,
    closeTimeout: 200,
};
function useReactionsPopup(reaction, ref) {
    const { value } = reaction;
    const { openedTooltip: currentHoveredReaction, setOpenedTooltip: setCurrentHoveredReaction } = (0, context_1.useReactionsContext)();
    const { delayedCall: setDelayedOpen, clearTimeoutRef: clearOpenTimeout } = useTimeoutRef();
    const { delayedCall: setDelayedClose, clearTimeoutRef: clearCloseTimeout } = useTimeoutRef();
    const open = react_1.default.useCallback(() => {
        setCurrentHoveredReaction({ reaction, open: true, ref });
    }, [reaction, ref, setCurrentHoveredReaction]);
    const close = react_1.default.useCallback(() => {
        clearOpenTimeout();
        if ((currentHoveredReaction === null || currentHoveredReaction === void 0 ? void 0 : currentHoveredReaction.reaction.value) === value && currentHoveredReaction.open) {
            setCurrentHoveredReaction(Object.assign(Object.assign({}, currentHoveredReaction), { open: false }));
        }
    }, [clearOpenTimeout, currentHoveredReaction, setCurrentHoveredReaction, value]);
    const focus = react_1.default.useCallback(() => {
        clearCloseTimeout();
        // If already hovered over current reaction
        if (currentHoveredReaction && currentHoveredReaction.reaction.value === reaction.value) {
            // But if it's not opened yet
            if (!currentHoveredReaction.open) {
                setDelayedOpen(open, DELAY.openTimeout);
            }
        }
        else {
            setCurrentHoveredReaction({ reaction, open: false, ref });
            setDelayedOpen(open, DELAY.openTimeout);
        }
    }, [
        clearCloseTimeout,
        currentHoveredReaction,
        open,
        reaction,
        ref,
        setCurrentHoveredReaction,
        setDelayedOpen,
    ]);
    const delayedOpenPopup = react_1.default.useCallback(() => {
        clearCloseTimeout();
        setDelayedOpen(focus, DELAY.focusTimeout);
    }, [clearCloseTimeout, focus, setDelayedOpen]);
    const delayedClosePopup = react_1.default.useCallback(() => {
        clearOpenTimeout();
        setDelayedClose(close, DELAY.closeTimeout);
    }, [clearOpenTimeout, close, setDelayedClose]);
    const onMouseEnter = delayedOpenPopup;
    const onMouseLeave = delayedClosePopup;
    react_1.default.useEffect(() => {
        // When the tab gets focus we need to hide the popup,
        // because the user might have changed the cursor position.
        window.addEventListener('focus', close);
        return () => {
            window.removeEventListener('focus', close);
        };
    }, [close]);
    return { onMouseEnter, onMouseLeave };
}
exports.useReactionsPopup = useReactionsPopup;
function useTimeoutRef() {
    const timeoutRef = react_1.default.useRef(null);
    const clearTimeoutRef = react_1.default.useCallback(() => {
        if (timeoutRef.current !== null) {
            clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
        }
    }, []);
    const delayedCall = react_1.default.useCallback((handler, delay) => {
        clearTimeoutRef();
        timeoutRef.current = setTimeout(handler, delay);
    }, [clearTimeoutRef]);
    return { delayedCall, clearTimeoutRef };
}

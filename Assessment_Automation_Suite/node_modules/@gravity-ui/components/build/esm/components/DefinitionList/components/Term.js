var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from 'react';
import { HelpPopover } from '../../HelpPopover';
import i18n from '../i18n';
import { b, getTitle } from '../utils';
function NoteElement({ note }) {
    if (!note) {
        return null;
    }
    const popoverClassName = b('item-note-tooltip');
    if (typeof note === 'string') {
        return (React.createElement(HelpPopover, { className: popoverClassName, content: note, placement: ['bottom', 'top'], buttonProps: {
                'aria-label': i18n('label_note'),
            } }));
    }
    if (typeof note === 'object') {
        const { buttonProps } = note, rest = __rest(note, ["buttonProps"]);
        return (React.createElement(HelpPopover, Object.assign({ className: popoverClassName, placement: ['bottom', 'top'], buttonProps: Object.assign({ 'aria-label': i18n('label_note') }, buttonProps) }, rest)));
    }
    return null;
}
export function Term({ note, name, nameTitle, multilineName, direction }) {
    const noteElement = (React.createElement(React.Fragment, null,
        "\u00A0",
        React.createElement(NoteElement, { note: note })));
    return (React.createElement(React.Fragment, null,
        React.createElement("div", { className: b('term-wrapper') },
            React.createElement("span", { title: getTitle(nameTitle, name) }, name),
            multilineName && noteElement),
        !multilineName && noteElement,
        direction === 'horizontal' && (React.createElement("div", { className: b('dots', { 'with-note': Boolean(note) }) }))));
}
